<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html>
<head>
  <title>Isometric Tilemap Game</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
  <style>
    body { margin: 0; display: flex; justify-content: center; align-items: center; height: 100vh; background: linear-gradient(#353458, #251725); overflow: hidden; }
    canvas { display: block; max-width: 100%; max-height: 100vh; }
  </style>
</head>
<body>
<script>
let tiles = [];
let tileSize = 48;
let tileHeight = 24;
let gridSize = 12;
let selectedTileType = 0;
let buttons = [];
let wasButtonClick = false;
let fallingTiles = [];
let lastPlacedI = -1;
let lastPlacedJ = -1;
let canvasWidth = 800;
let canvasHeight = 600;

const heightPixel = 8;
const extrudeDY = -heightPixel;
const fallFromHeight = -300;

const tileTypes = [
  { base: { r: 19, g: 12, b: 28 } }, // Ringo
  { base: { r: 57, g: 33, b: 54 } }, // Bingo
  { base: { r: 138, g: 81, b: 72 } }, // Jingo
  { base: { r: 187, g: 140, b: 135 } }, // Tango
  { base: { r: 141, g: 66, b: 66 } }  // Mango
];

const tileNames = ['Ringo', 'Bingo', 'Jingo', 'Tango', 'Mango'];

function setup() {
  resizeCanvas(windowWidth * 0.9, windowHeight * 0.9); // Start with 90% of window size
  canvasWidth = width;
  canvasHeight = height;
  tileSize = canvasWidth / 16; // Dynamic sizing based on canvas
  tileHeight = tileSize / 2;
  for (let i = 0; i < gridSize; i++) {
    tiles[i] = [];
    for (let j = 0; j < gridSize; j++) {
      tiles[i][j] = { stack: [], dropAnimStart: 0, dropOffset: 0 };
    }
  }
  for (let i = 0; i < 5; i++) {
    buttons.push({ x: canvasWidth - 100, y: 100 + i * 60, type: i, size: 50 });
  }
}

function windowResized() {
  resizeCanvas(windowWidth * 0.9, windowHeight * 0.9);
  canvasWidth = width;
  canvasHeight = height;
  tileSize = canvasWidth / 16;
  tileHeight = tileSize / 2;
  for (let i = 0; i < buttons.length; i++) {
    buttons[i].x = canvasWidth - 100;
    buttons[i].y = 100 + i * 60;
  }
}

function draw() {
  clear();

  let offsetX = canvasWidth * 0.25; // 25% from left
  let offsetY = canvasHeight * 0.167; // ~100px at 600px height, scaled

  // Draw floor grid
  for (let i = 0; i < gridSize; i++) {
    for (let j = 0; j < gridSize; j++) {
      let x = offsetX + (i - j) * tileSize / 2;
      let y = offsetY + (i + j) * tileHeight / 2;
      push();
      translate(x, y);
      stroke(0, 255, 255);
      strokeWeight(0.5);
      noFill();
      beginShape();
      vertex(-tileSize / 2, 0);
      vertex(0, -tileHeight / 2);
      vertex(tileSize / 2, 0);
      vertex(0, tileHeight / 2);
      endShape(CLOSE);
      pop();
    }
  }

  // Draw stacks
  for (let depth = 0; depth < gridSize * 2 - 1; depth++) {
    for (let i = Math.max(0, depth - gridSize + 1); i <= Math.min(depth, gridSize - 1); i++) {
      let j = depth - i;
      let x = offsetX + (i - j) * tileSize / 2;
      let y = offsetY + (i + j) * tileHeight / 2;
      let tile = tiles[i][j];

      let extraDY = tile.dropOffset;
      if (tile.dropAnimStart > 0) {
        let t = (millis() - tile.dropAnimStart) / 300;
        if (t < 1) {
          t = easeInOutCubic(t);
          extraDY = lerp(extrudeDY, 0, t);
        } else {
          extraDY = 0;
          tile.dropAnimStart = 0;
        }
        tile.dropOffset = extraDY;
      }

      push();
      translate(x, y + extraDY);

      for (let k = 0; k < tile.stack.length; k++) {
        let layer = tile.stack[k];
        let bottomDY = k * extrudeDY;
        let topDY = bottomDY + extrudeDY;

        let baseCol = tileTypes[layer.type].base;
        let lightAmount = k / 19;
        let topR = baseCol.r + (255 - baseCol.r) * lightAmount * 0.7; // Brighter top
        let topG = baseCol.g + (255 - baseCol.g) * lightAmount * 0.7;
        let topB = baseCol.b + (255 - baseCol.b) * lightAmount * 0.7;

        let sideR = topR * 0.7 + 15; // Warmer right side (increased red)
        let sideG = topG * 0.7 + 10; // Slight yellow shift for warmth
        let sideB = topB * 0.7;

        let strokeR = sideR * 0.8;
        let strokeG = sideG * 0.8;
        let strokeB = sideB * 0.8;

        let layerOffsetY = layer.fallOffset;
        if (layer.fallStart > 0) {
          let t = (millis() - layer.fallStart) / 300;
          if (t < 1) {
            t = easeInOutCubic(t);
            layerOffsetY = lerp(fallFromHeight, 0, t);
          } else {
            layerOffsetY = 0;
            layer.fallStart = 0;
          }
          layer.fallOffset = layerOffsetY;
        }

        push();
        translate(0, layerOffsetY);

        stroke(strokeR, strokeG, strokeB);
        strokeWeight(0.5);

        fill(sideR, sideG, sideB, 255); // Fully opaque

        beginShape();
        vertex(-tileSize / 2, bottomDY);
        vertex(-tileSize / 2, topDY);
        vertex(0, topDY + tileHeight / 2);
        vertex(0, bottomDY + tileHeight / 2);
        endShape(CLOSE);

        beginShape();
        vertex(tileSize / 2, bottomDY);
        vertex(tileSize / 2, topDY);
        vertex(0, topDY + tileHeight / 2);
        vertex(0, bottomDY + tileHeight / 2);
        endShape(CLOSE);

        fill(topR, topG, topB, 255); // Fully opaque
        beginShape();
        vertex(-tileSize / 2, topDY);
        vertex(0, topDY - tileHeight / 2);
        vertex(tileSize / 2, topDY);
        vertex(0, topDY + tileHeight / 2);
        endShape(CLOSE);

        pop();
      }
      pop();
    }
  }

  // Draw falling tiles
  for (let fi = fallingTiles.length - 1; fi >= 0; fi--) {
    let ft = fallingTiles[fi];
    let t = (millis() - ft.startTime) / 2000;
    if (t > 1) {
      fallingTiles.splice(fi, 1);
      continue;
    }
    let prog = easeOutQuad(t);
    let curY = ft.posY + prog * 1200;
    let curX = ft.posX;
    let rot = prog * 720 * ft.rotationSpeed;

    let baseCol = tileTypes[ft.type].base;
    let topR = baseCol.r;
    let topG = baseCol.g;
    let topB = baseCol.b;
    let sideR = topR * 0.7 + 15;
    let sideG = topG * 0.7 + 10;
    let sideB = topB * 0.7;
    let strokeR = sideR * 0.8;
    let strokeG = sideG * 0.8;
    let strokeB = sideB * 0.8;

    push();
    translate(curX, curY);
    rotate(rot);

    stroke(strokeR, strokeG, strokeB);
    strokeWeight(0.5);

    fill(sideR, sideG, sideB, 255);
    beginShape();
    vertex(-tileSize / 2, 0);
    vertex(-tileSize / 2, extrudeDY);
    vertex(0, tileHeight / 2 + extrudeDY);
    vertex(0, tileHeight / 2);
    endShape(CLOSE);
    beginShape();
    vertex(tileSize / 2, 0);
    vertex(tileSize / 2, extrudeDY);
    vertex(0, tileHeight / 2 + extrudeDY);
    vertex(0, tileHeight / 2);
    endShape(CLOSE);

    fill(topR, topG, topB, 255);
    beginShape();
    vertex(-tileSize / 2, extrudeDY);
    vertex(0, -tileHeight / 2 + extrudeDY);
    vertex(tileSize / 2, extrudeDY);
    vertex(0, tileHeight / 2 + extrudeDY);
    endShape(CLOSE);

    pop();
  }

  // Draw UI window
  fill(34, 38, 57); // #222639
  noStroke();
  rect(canvasWidth - 125, 75, 100, 320, 10); // 25px padding on all sides, rounded

  // Draw selected tile name
  textAlign(CENTER);
  textSize(16);
  fill(255);
  text(tileNames[selectedTileType] || 'None', canvasWidth * 0.5, 30); // 70px above buttons, centered

  // Draw buttons
  for (let btn of buttons) {
    let baseCol = tileTypes[btn.type].base;
    let isSelected = btn.type === selectedTileType;
    if (isSelected) {
      stroke(255, 255, 255, 220); // Highlight stroke
      strokeWeight(1);
      drawingContext.shadowColor = 'rgba(255, 255, 255, 0.8)'; // Intense glow
      drawingContext.shadowBlur = 20;
    } else {
      noStroke();
      drawingContext.shadowColor = 'rgba(0, 0, 0, 0.4)';
      drawingContext.shadowBlur = 8;
    }
    fill(baseCol.r, baseCol.g, baseCol.b);
    rect(btn.x, btn.y, btn.size, btn.size, 10); // Rounded corners
  }
  drawingContext.shadowBlur = 0;

}

function placeTile(force = false) {
  let offsetX = canvasWidth * 0.25;
  let offsetY = canvasHeight * 0.167;
  let dx = mouseX - offsetX;
  let dy = mouseY - offsetY;
  let u = dx / tileSize + dy / tileHeight;
  let v = dy / tileHeight - dx / tileSize;
  let i = floor(u + 0.5);
  let j = floor(v + 0.5);
  if (i >= 0 && i < gridSize && j >= 0 && j < gridSize && (force || i !== lastPlacedI || j !== lastPlacedJ)) {
    let tile = tiles[i][j];
    let stack = tile.stack;
    let animTime = millis();
    if (stack.length < 20) {
      stack.push({ type: selectedTileType, fallStart: animTime, fallOffset: fallFromHeight });
    } else {
      let bottom = stack.shift();
      fallingTiles.push({
        type: bottom.type,
        posX: offsetX + (i - j) * tileSize / 2,
        posY: offsetY + (i + j) * tileHeight / 2,
        startTime: millis(),
        rotationSpeed: random(-1, 1)
      });
      stack.push({ type: selectedTileType, fallStart: animTime, fallOffset: fallFromHeight });
      tile.dropAnimStart = millis();
      tile.dropOffset = extrudeDY;
    }
    lastPlacedI = i;
    lastPlacedJ = j;
  }
}

function mousePressed() {
  // Check button clicks
  for (let btn of buttons) {
    if (mouseX > btn.x && mouseX < btn.x + btn.size && mouseY > btn.y && mouseY < btn.y + btn.size) {
      selectedTileType = btn.type;
      wasButtonClick = true;
      return;
    }
  }
  wasButtonClick = false;
  placeTile(true); // Force placement on initial press
}

function mouseDragged() {
  if (wasButtonClick) return;
  placeTile();
}

function mouseReleased() {
  wasButtonClick = false;
  lastPlacedI = -1;
  lastPlacedJ = -1;
}

function easeInOutCubic(t) {
  return t < 0.5 ? 4 * t * t * t : 1 - pow(-2 * t + 2, 3) / 2;
}

function easeOutQuad(t) {
  return 1 - (1 - t) * (1 - t);
}
</script>
</body>
</html>